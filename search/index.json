[{"content":" 先搭建一个简单的目标检测demo 尝试在算力板上部署 实现算力板和DSP的通信 最后进行无人系统的开发 答辩的坑 无人系统的应用扩张 1. 智能城市 在智能城市中，智能无人系统可以扮演重要的角色，具体应用包括：\n无人巡逻与监控：利用无人机或自动驾驶巡逻车进行城市的实时巡逻，配合计算机视觉和目标识别技术，可以实现智能监控，对异常行为（如盗窃、打架、交通事故等）进行实时识别和报警，从而提高城市安全性。 交通管理与监控：通过无人驾驶车辆或无人机进行道路状况监测，实时收集交通数据，对交通流量、交通拥堵、违法行为进行分析和反馈，有助于交通管理系统的优化。 环境监测：无人机可以搭载传感器，进行空气质量、水体污染、噪音等环境监测，实时反馈环境数据，帮助城市管理者及时采取措施。 垃圾清运与智能废弃物管理：智能无人车可自动化执行垃圾清运任务，结合目标识别技术，智能区分垃圾类别，从而提高城市垃圾管理效率。 2. 灾难救援 在灾难救援中，智能无人系统能通过边缘计算与目标识别技术发挥重要作用：\n无人机搜救：在地震、洪水等自然灾害中，无人机可用来快速识别灾区的情况，帮助定位被困人员，获取实时图像和数据，减少人工救援的风险和时间。 灾区监测：通过无人机在灾区上空进行持续巡航，实时监测灾区的变化，帮助灾难指挥中心获取更精确的数据来做出决策。 危险物品检测：智能无人系统可以在危险区域执行任务，如检测有毒气体泄漏、火灾等，减少对人类生命的威胁。 3. 环境监测 智能无人系统还可以用于更广泛的环境监测领域：\n大气污染监测：无人机搭载气体传感器，可以在难以到达的区域（如高空、海洋等）进行环境监测，收集空气质量、温度、湿度等数据，为环境保护政策提供数据支持。 生态保护与监测：在森林、野生动物栖息地等区域，无人系统可以通过自动飞行进行生态监测，检测非法砍伐、偷猎等行为，保护生态环境。 水质监测：无人船、无人机可以用于水体的监测，实时分析水质变化，发现污染源并迅速采取措施，保证水资源的安全与可持续使用。 这些应用展示了边缘计算和目标识别技术如何在智能无人系统中得到充分利用，推动无人系统在各个行业中的普及和应用，提升效率、降低成本并增强系统的智能化水平。\n参考文献 Bringing AI to edge: From deep learning\u0026rsquo;s perspective Edge deep learning in computer vision and medical diagnostics: a comprehensive survey Deep Learning With Edge Computing: A Review**** Deep learning: systematic review, models, challenges, and research directions 毕业设计要求 论文方面\n字数够\n过查重\n格式对\n展示\n可视化 用户登录和管理 增加一个模型训练、更新、部署界面 ","date":"2025-02-26T00:00:00Z","image":"https://raw.githubusercontent.com/chirouo/my_blog_img/main/xdc1.jpg","permalink":"https://example.com/p/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1-%E6%97%A0%E4%BA%BA%E7%B3%BB%E7%BB%9F/","title":"毕业设计-无人系统"},{"content":"YEMU 端序和位域 位域\nC语言结构体定义位域，从bit0开始，依次到最高bit位 - Risun_Lee - 博客园\n样例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 typedef union { struct { uint8_t rs : 2, rt : 2, op : 4; } rtype; struct { uint8_t addr : 4 , op : 4; } mtype; uint8_t inst; } inst_t; uint8_t M[NMEM] = { // 内存, 其中包含一个计算z = x + y的程序 0b11100110, // load 6# | R[0] \u0026lt;- M[y] 0b00000100, // mov r1, r0 | R[1] \u0026lt;- R[0] 0b11100101, // load 5# | R[0] \u0026lt;- M[x] 0b00010001, // add r0, r1 | R[0] \u0026lt;- R[0] + R[1] 0b11110111, // store 7# | M[z] \u0026lt;- R[0] 0b00010000, // x = 16 0b00100001, // y = 33 0b00000000, // z = 0 }; inst_t this = M[0]; //C语言中位域从低到高排列this.rtype.op != 0110, == 1110 端序（Endianness）：\n端序是指多字节数据在内存中的存储顺序\n小端：低字节存储在低地址（x86常用）\n大端：高字节存储在低地址（网络字节序）\n样例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // 位域结构体 typedef union { struct { uint8_t a : 4; uint8_t b : 4; } bits; uint8_t byte; } BitField; // 检查端序的联合体 typedef union { uint16_t value; uint8_t bytes[2]; } EndianTest; int main() { // 测试位域排列 BitField bf; bf.byte = 0x12; // 0001 0010 printf(\u0026#34;位域测试:\\n\u0026#34;); printf(\u0026#34;完整字节: 0x%02x\\n\u0026#34;, bf.byte); printf(\u0026#34;低4位(a): 0x%x\\n\u0026#34;, bf.bits.a); printf(\u0026#34;高4位(b): 0x%x\\n\u0026#34;, bf.bits.b); // 测试端序 EndianTest et; et.value = 0x1234; printf(\u0026#34;\\n端序测试:\\n\u0026#34;); printf(\u0026#34;完整数值: 0x%04x\\n\u0026#34;, et.value); printf(\u0026#34;第一个字节: 0x%02x\\n\u0026#34;, et.bytes[0]); printf(\u0026#34;第二个字节: 0x%02x\\n\u0026#34;, et.bytes[1]); return 0; } /*运行结果 位域测试: 完整字节: 0x12 低4位(a): 0x2 高4位(b): 0x1 端序测试: 完整数值: 0x1234 第一个字节: 0x34 第二个字节: 0x12 */ /*题外话 结构体 EndianTest 中的bytes[2]在内存中的排列方式是： bytes[0] = 0x34（低字节）在低地址 bytes[1] = 0x12（高字节）在高地址 即\tbytes[0]\tbytes[1] 0x34\t0x12\tx86的小端存储 */ 总结：x86上端序是从低到高 小端序；c语言编译器决定位域，位域一般也是从低到高（先声明变量的在低位，后声明的在高位）\n指令周期 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 取指 --\u0026gt; 译码（操作码译码和操作数译码）--\u0026gt; 执行 cmd_c() --\u0026gt; cpu_exec(uint64_t n) --\u0026gt; execute(uint64_t n) --\u0026gt; exec_once(Decode *s, vaddr_t pc) --\u0026gt; isa_exec_once(Decode *s)//进入 riscv_32 --\u0026gt; inst_fetch(vaddr_t *pc, int len) decode_exec(Decode *s) --\u0026gt; #define INSTPAT_START(name) { const void * __instpat_end = \u0026amp;\u0026amp;concat(__instpat_end_, name); --\u0026gt; INSTPAT(\u0026#34;??????? ????? ????? ??? ????? 00101 11\u0026#34;, auipc , U, R(rd) = s-\u0026gt;pc + imm); --\u0026gt; pattern_decode(pattern, STRLEN(pattern), \u0026amp;key, \u0026amp;mask, \u0026amp;shift); INSTPAT_MATCH(s, ##__VA_ARGS__); --\u0026gt; decode_operand(s, \u0026amp;rd, \u0026amp;src1, \u0026amp;src2, \u0026amp;imm, concat(TYPE_, type)); __VA_ARGS__ ; --\u0026gt; #define INSTPAT_END(name) concat(__instpat_end_, name): ; } --\u0026gt; R(0) = 0; ","date":"2025-02-20T00:00:00Z","image":"https://raw.githubusercontent.com/chirouo/my_blog_img/main/xdc1.jpg","permalink":"https://example.com/p/pa2/","title":"PA2"},{"content":" 先搭建一个简单的目标检测demo 尝试在算力板上部署 实现算力板和DSP的通信 最后进行无人机控制系统的开发 chirouo: 分析下这个项目是做什么的\nWorkspace: 正在收集工作区信息正在筛选到最相关的信息\nchirouo: 分析下这个项目是做什么的\nWorkspace: 正在收集工作区信息根据代码分析，这是一个飞控系统项目（ANO Pioneer Pro飞控），主要实现无人机/飞行器的姿态控制、导航等功能。具体分析如下:\n主要功能模块 姿态传感器校准模块 在 Ano_Imu_Calibration.c 中实现加速度计和陀螺仪的校准功能 通过采样 1000 次数据来获取平均值，消除传感器误差 实现传感器稳定性检测功能 飞行控制系统 1 2 3 4 5 - 姿态控制 (Ano_AttCtrl.c) - 定位控制 (Ano_LocCtrl.c) - 高度控制 (Ano_AltCtrl.c) - 电机控制 (Ano_MotorCtrl.c) - 遥控控制 (Ano_RC.c) 传感器驱动 1 2 3 4 - 光流传感器 (Ano_OF.c) - IMU传感器 (BMI088/ICM20602) - 气压计 (SPL06) - 磁力计 (AK8975/AK09915) 系统任务调度 通过 Ano_Scheduler.c 实现多任务调度（当成RTOS用） 1000Hz、100Hz 等不同频率的任务循环 特点 使用 STM32F4 系列MCU作为主控芯片\n支持多种姿态解算:\n四元数算法 陀螺仪积分 磁力计辅助姿态修正 丰富的控制模式: GPS 定位 光流定位 UWB 定位 视觉跟踪 完善的教研宝功能和数据下传功能 总的来说这是一个完整的无人机飞控系统,能够实现稳定的飞行控制、定位导航等功能。核心是通过传感器数据融合来实现对飞行器姿态和位置的精确控制。\nchirouo: 设置一下打开这个文件夹用GB2312编码\nGitHub Copilot: 在 VS Code 中设置 GB2312 编码的步骤如下:\n方法一：通过命令面板 1 2 3 4 1. 按 Ctrl + Shift + P 打开命令面板 2. 输入 \u0026#34;Change File Encoding\u0026#34; 3. 选择 \u0026#34;重新打开文件编码\u0026#34; 4. 选择 \u0026#34;GB 2312\u0026#34; 或 \u0026#34;GBK\u0026#34; 方法二：通过状态栏 1 2 3 1. 点击 VS Code 窗口底部状态栏的 \u0026#34;UTF-8\u0026#34; 按钮 2. 选择 \u0026#34;通过编码重新打开\u0026#34; 3. 选择 \u0026#34;GB 2312\u0026#34; 或 \u0026#34;GBK\u0026#34; 方法三：在工作区设置中配置 在项目根目录创建或编辑 .vscode/settings.json:\n1 2 3 4 5 6 7 8 9 { \u0026#34;files.encoding\u0026#34;: \u0026#34;gb2312\u0026#34;, \u0026#34;[c]\u0026#34;: { \u0026#34;files.encoding\u0026#34;: \u0026#34;gb2312\u0026#34; }, \u0026#34;[h]\u0026#34;: { \u0026#34;files.encoding\u0026#34;: \u0026#34;gb2312\u0026#34; } } 这将为整个工作区设置默认编码为 GB2312。这样可以保证:\n所有源文件都以 GB2312 编码打开 中文注释能正确显示 新建文件默认使用 GB2312 编码 建议使用方法三,这样可以确保团队成员打开项目时都使用相同的编码设置。\nchirouo: 这个文件命名的每个单词啥意思\nGitHub Copilot: 让我分析下文件名 Ano_Imu_Data.c 中每个单词的含义：\nAno\nAno 是 \u0026ldquo;Anoxia\u0026rdquo;（匿名）的缩写 这是匿名科创公司的产品标识前缀 IMU\nIMU = Inertial Measurement Unit 译为：惯性测量单元 是飞行器中用于测量角速度和加速度的传感器单元 通常包含: 陀螺仪(测量角速度) 加速度计(测量线性加速度) Data\n表示这个文件处理 IMU 相关的数据 包含数据采集、处理和计算等功能 主要功能：\nIMU传感器灵敏度初始化 IMU原始数据获取 IMU温度数据获取 IMU数据计算处理(坐标转换、单位转换等) 综上，这个文件是匿名科创飞控系统中负责处理惯性测量单元(IMU)数据的驱动程序文件。\nchirouo: 什么是imu\nGitHub Copilot: # IMU (惯性测量单元) 详解\n基本概念 IMU (Inertial Measurement Unit) 是一种测量物体三轴姿态角(俯仰、横滚、航向)、角速度和加速度的电子器件。可以理解为一个高精度的\u0026quot;电子罗盘\u0026quot;。\nIMU的核心传感器 陀螺仪\n测量角速度（旋转速度） 单位：°/s（度/秒）或 rad/s（弧度/秒） 三轴：pitch(俯仰)、roll(横滚)、yaw(航向) 加速度计\n测量线性加速度 单位：g（重力加速度）或 m/s² 三轴：X、Y、Z方向的加速度 在无人机中的应用 1 2 3 4 5 6 7 8 9 10 11 1. 姿态测量 - 实时获取飞行器的空间姿态 - 为飞控系统提供姿态反馈 2. 运动控制 - 辅助定高、定点飞行 - 保持飞行稳定性 3. 导航定位 - 结合GPS等进行位置估计 - 实现自主导航功能 代码示例 从项目中可以看到IMU相关的核心代码：\n1 2 3 4 5 6 7 8 void ImuDataCalcu(u8 ins_calibrated,vec3_f gyrOffset,vec3_f accOffset,float IEM[3][3]) { // 处理陀螺仪数据 st_imuData.f_gyr_dps[i] = (st_imuData.f_gyrRaw[i] - gyrOffset[i])*st_imuData.gyrSensitivity[i]; // 处理加速度计数据 st_imuData.f_acc_cmpss[i] = (st_imuData.f_accRaw[i] - accOffset[i])*st_imuData.accSensitivity[i]; } 数据处理流程 获取原始数据 消除零偏误差 单位转换 坐标系转换 姿态解算 输出控制量 IMU是现代飞行器不可或缺的关键传感器，为飞行器的自主控制提供了基础数据支持。\nchirouo: 现在ANO_PIONEERPRO-088是基于stm32F407的，我想将基于我自己的芯片，把源码里的程序，尤其是驱动部分进行替换，我改如何下手呢@\nGitHub Copilot: 要将 ANO_PioneerPro-088 从 STM32F407 移植到其他芯片平台，建议按以下步骤进行：\n分析项目结构 1 2 3 4 5 6 7 项目主要分为几个层次： /SRC /applications - 应用层 /drivers - 硬件驱动层 /fc_general - 飞控通用功能 /fc_specific - 飞控特定功能 /AnoImu - IMU相关算法 重点关注驱动层替换 需要重写的核心驱动文件: 1 2 3 4 5 6 7 8 9 /SRC/drivers/ ├── Drv_adc.c // ADC驱动 ├── Drv_gpio.c // GPIO驱动 ├── Drv_i2c.c // I2C驱动 ├── Drv_pwm_out.c // PWM输出 ├── Drv_spi.c // SPI驱动 ├── Drv_time.c // 定时器 ├── Drv_uart.c // 串口通信 └── Drv_bsp.c // 板级支持包 移植步骤 (1) 创建硬件抽象层\n1 2 3 4 5 6 7 8 // hardware.h // 定义硬件抽象接口 typedef struct { void (*gpio_init)(void); void (*uart_init)(void); void (*spi_init)(void); // ...其他硬件接口 } hw_ops_t; (2) 实现目标平台的驱动\n1 2 3 4 5 6 7 8 9 // your_mcu_driver.c #include \u0026#34;hardware.h\u0026#34; static hw_ops_t hw_ops = { .gpio_init = your_gpio_init, .uart_init = your_uart_init, .spi_init = your_spi_init, // ...实现其他接口 }; (3) 修改 BSP 初始化\n1 2 3 4 5 6 7 8 9 // Drv_BSP.c void BSP_Init(void) { // 替换为新平台的初始化代码 hw_ops.gpio_init(); hw_ops.uart_init(); hw_ops.spi_init(); // ... } 保持接口兼容 确保新驱动实现与原有上层代码的接口保持一致:\n1 2 3 4 5 6 7 8 9 10 // 例如 PWM 接口 void Drv_PwmOut_Init(void) { // 替换实现,但保持函数名和参数不变 } void Drv_PwmOut_Update(uint16_t *pwm_set) { // 替换实现,但保持接口一致 } 分步调试\n先移植基础驱动(GPIO/UART)\n实现传感器驱动(IMU/气压计等)\n调试控制算法\n整体功能测试\n注意事项\n保持算法层代码不变\n关注中断处理的差异\n确保定时器精度\n注意传感器时序要求\n建议先从小规模测试开始，逐步扩大移植范围，确保每个模块都能正常工作后再整体联调。\nchirouo: 按你说的 如果我先移植简单的GPIO之后该如何调试程序，才知道自己移植成功了呢\nGitHub Copilot: 对于GPIO驱动移植的调试验证，我建议按以下步骤进行：\n创建简单的LED测试程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // test_gpio.c void LED_Test(void) { // 1. GPIO初始化 GPIO_InitTypeDef GPIO_InitStructure; // 2. 时钟使能 (根据你的芯片修改) EnableGPIOClock(); // 3. GPIO配置 (根据你的芯片修改) GPIO_InitStructure.GPIO_Pin = LED_PIN; GPIO_InitStructure.GPIO_Mode = GPIO_MODE_OUTPUT; GPIO_InitStructure.GPIO_Speed = GPIO_SPEED_HIGH; GPIO_Init(LED_PORT, \u0026amp;GPIO_InitStructure); // 4. LED闪烁测试 while(1) { GPIO_SetBits(LED_PORT, LED_PIN); // LED亮 Delay_ms(500); // 延时500ms GPIO_ResetBits(LED_PORT, LED_PIN); // LED灭 Delay_ms(500); // 延时500ms } } 修改启动代码，只保留最基础功能 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 int main(void) { // 1. 初始化系统时钟 SystemInit(); // 2. 初始化延时函数 Delay_Init(); // 3. 运行LED测试程序 LED_Test(); while(1) { // 空循环 } } 调试步骤 使用示波器检查: 1 2 1. 测量GPIO输出波形 2. 验证翻转频率是否为1Hz(500ms高电平+500ms低电平) 使用逻辑分析仪: 1 2 1. 捕获GPIO状态变化 2. 验证时序是否正确 使用调试器: 1 2 3 4 // 设置断点观察: 1. GPIO初始化函数 2. GPIO翻转函数 3. 寄存器配置值 验证成功的标准 1 2 3 4 1. LED能够正常闪烁 2. GPIO输出波形符合预期 3. 时序参数满足要求 4. 功耗指标正常 常见问题排查 1 2 3 4 5 6 7 8 9 10 11 12 13 14 if (LED不亮) { 检查: - 时钟是否使能 - GPIO配置是否正确 - 引脚电平是否正确 - 硬件连接是否正常 } if (LED不闪烁) { 检查: - 延时函数是否正常 - 主循环是否正常运行 - 是否有其他中断干扰 } 最终验证 一旦基本GPIO功能验证通过，可以逐步添加:\n1 2 3 4 5 6 7 8 9 10 11 12 13 void Progressive_Test(void) { // 1. 基础GPIO功能 Test_GPIO_Basic(); // 2. 中断功能 Test_GPIO_Interrupt(); // 3. 复用功能 Test_GPIO_Alternate(); // 4. 综合测试 Test_GPIO_All(); } 通过这种渐进式的测试方法，可以确保GPIO驱动移植的正确性，为后续更复杂外设的移植打下基础。\nchirouo: gyr是什么组件的缩写\nGitHub Copilot: gyr 是 Gyroscope (陀螺仪) 的缩写。\n在这个飞控代码中，BMI088是一个集成了陀螺仪(Gyroscope)和加速度计(Accelerometer)的惯性测量传感器。具体可以看到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // BMI088相关的GPIO控制函数 void DrvGpioCsPinCtrlBmi088Gyr(u8 ena) // Gyr = Gyroscope 陀螺仪 { if ( ena ) GPIO_ResetBits ( BMI088_CSPOT_GYR, BMI088_CSPIN_GYR ); else GPIO_SetBits ( BMI088_CSPOT_GYR, BMI088_CSPIN_GYR ); } void DrvGpioCsPinCtrlBmi088Acc(u8 ena) // Acc = Accelerometer 加速度计 { if ( ena ) GPIO_ResetBits ( BMI088_CSPOT_ACC, BMI088_CSPIN_ACC ); else GPIO_SetBits ( BMI088_CSPOT_ACC, BMI088_CSPIN_ACC ); } 陀螺仪(Gyroscope)的主要功能：\n测量角速度 检测旋转运动 维持飞行器姿态稳定 提供航向参考 在飞控系统中，陀螺仪和加速度计通常配合使用，共同构成IMU(惯性测量单元)，用于实现飞行器的姿态控制。\n资料 飞控课程（一）：无人机介绍_哔哩哔哩_bilibili\n电调 电机驱动模块，常用的是：正负极输入，UVW三项输出，PWM控制信号输入（PWM信号的频率要参考电调手册）\nIMU（姿态传感器） 三轴陀螺仪（俯仰角和翻转角） 三轴加速计（俯仰角和翻转角） 地磁场传感器（偏航角） 气压计 UBW 超声波 无人机遥控器和接受机 将 油门的前后推拉程度 转换成 脉宽（占空比） 电池： 一般用锂电池（三元锂、磷酸铁铝，一般用三元锂），能量密度大\n电池在串联的时候电压会增加，但容量不增加，放电倍率（即电流）不会增加\n电池在并联的时候电压不会增加，但容量会增加，放电倍率（即电流）会增加\n飞控 固定翼飞机不需要飞控，但是多旋翼无人机，人不可能一次性控制多个机翼，因此需要交给飞控去进行姿态控制\n飞控课程47:57 / 55:05 介绍四个电机如何旋转 才能 让 无人机 上下 前后 翻转 以及最难的左右偏航。\n进动扭矩相关知识：左右偏航是反扭矩互相抵消，四旋翼一定是对角电机旋转方向相同（这样的话两对角电机即使转速不一样无人机的平衡也不会受阻）\n如果向右偏航，就是右对角电机（逆时针转）转速上升，左对角电机（顺时针转）转速下\n飞控接受控制信号，转换成电调信号，电调再控制电机\n飞控接受的控制信号有下面几种\n遥控器最原始数据：油门、翻转、左右偏航、前后 直接告诉飞控 往前、后、左、右、上、下、翻转 通过传感器直接告诉无人机，你的位置在哪，建模，给个（x,y,z)坐标，直接飞过去 材料选型 电机和桨叶 大KV配小桨叶，小KV配大桨叶\n","date":"2025-02-20T00:00:00Z","image":"https://raw.githubusercontent.com/chirouo/my_blog_img/main/xdc1.jpg","permalink":"https://example.com/p/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/","title":"毕业设计"},{"content":"宏观git drop和show可以+栈索引\ngit reset 命令 1 2 3 4 5 6 7 # 基本语法 git reset [--soft | --mixed | --hard] [commit_id] reset默认不加任何参数的时候是--mixed行为 # 三种模式 --soft # 只重置HEAD指针 --mixed # 重置HEAD指针和暂存区 --hard # 重置HEAD指针、暂存区和工作区 \u0026ndash;soft模式\n1 2 3 4 5 git reset --soft HEAD~n # 效果： # 1. 只移动HEAD指针 # 2. 撤销最近n次的提交，但保留所有修改在暂存区中，可以重新提交。 # 3. 常用于修改最近的commit信息 \u0026ndash;mixed模式（默认）\n1 2 3 4 5 6 7 8 git reset [HEAD~n | HEAD fileA] # 或 git reset --mixed [HEAD~n | HEAD fileA] # 效果： # 1. 移动HEAD指针 # 2. 重置暂存区到前n次的版本（不会丢失任何更改，只是将文件状态从\u0026#34;已暂存\u0026#34;变回\u0026#34;已修改\u0026#34;，如果指定了文件fileA，就只对这一个文件进行这样的操作） # 3. 保留工作区的修改 # 4. 常用于合并多个提交 \u0026ndash;hard模式\n1 2 3 4 5 6 git reset --hard HEAD~n # 效果： # 1. 移动HEAD指针 # 2. 重置暂存区和工作区 # 3. 危险操作：会丢失未提交的修改（直接回到前n次的版本，工作区和暂存区都没有任何缓存） # 4. 常用于完全放弃最近的提交 git checkout 命令 checkout + 分支，可以切分枝， +文件，可以把工作区的改动撤销\n1 2 3 4 5 6 7 8 # 切换分支 git checkout branch_name # 创建并切换分支 git checkout -b new_branch # 从工作区检出（删除）特定文件 git checkout -- file_name git diff 命令 使用示例\n1 2 3 4 5 6 7 8 9 10 # 比较暂存区和工作区的差异\t（工作区有，暂存区没有，显示+） git diff [-- path/file_name] # 比较版本库和暂存区中的差异\t（暂存区有，版本库中没有，显示+） git diff --cached [-- path/file_name] # 比较版本库和工作区的差异\t（工作区有，版本库中没有，显示+） git diff HEAD [-- path/file_name] # 比较不同提交之间的差异\t（to_commit有，from_commit中没有，显示+） git diff \u0026lt;from_commit\u0026gt; \u0026lt;to_commit\u0026gt; [-- path/file_name] # 比较不同分支之间的差异\t（branchA有，branchB中没有，显示+） git diff main develop 最佳实践\n1 2 3 4 5 6 7 # 检查即将提交的内容（即检查版本库和暂存区之间的差异） git diff --cached # 查看完整的修改 git status # 先查看文件状态 git diff # 查看未暂存的改动（即检查暂存区和工作区之间的差异） git diff --cached # 查看已暂存的改动 对运行完git diff命令后类似@@ -xxx,x +xxx,x @@的解释\ngit stash 命令 入栈\n1 2 3 git stash git stash save \u0026#34;comment\u0026#34; git stash push -m（新版本） 出栈\n1 2 3 4 # 应用并删除最近的暂存 git stash pop # 应用最近的暂存（但是不删除） git stash apply 删除\n1 2 3 4 # 清除栈中所有暂存 git stash clear # 删除指定stash_id的暂存 git stash drop stash@{n} 查\n1 2 3 4 # 列出所有暂存 git stash list # 展示指定stash_id的暂存 git stash show stash@{n} git log 命令 git 多分支开发工作流git cherry pick 命令 1 2 3 4 5 6 7 8 # 第一种 git cherry-pick 4_commit_id # 第二种 git cherry-pick 4_commit_id 8_commit_id\tmerge 4和8 变成 4’和8’后放到当前分支上 # 第三种 git cherry-pick 4_commit_id..8_commit_id\tmerge (4, 8]变成(4,8]’后放到当前分支上 # 第四种 git cherry-pick 4_commit_id^..8_commit_id\tmerge [4, 8]变成[4,8]’后放到当前分支上 git rebase 和 git merge 的区别 在main上 git merge develop：\n在 main 上 git rebase develop：\n会把develop的4和6节点嫁接到main和develop的公共parent3之后\n再把main在parent3之后的commit节点7 和 5 变成变成新的commit 节点7' 5'放到develop之后\ngit rebase会打乱时间顺序，但是合并之后很清爽，自己舍取优缺点\n应用场景\n1 2 一个新的需求，就按这个需求开一个新分支，当主分支有新增内容时（其他小伙伴合入代码了），且新增的内容对自己的新代码有影响，那么就rebase下主分支，将主分支的内容同步过来，并解决下自己的代码，比如冲突啥的，适配主分支的新代码。自己的需求开发完毕后，提MR，merge合入到主分支 尽量不要在公共分支rebase，公共分支例如main，用merge git 多分支开发工作流 基础操作 远程仓库操作\n1 2 3 4 5 6 7 8 9 10 11 12 # 查看远程仓库 git remote -v # 查看所有分支 git branch -a # 更新远程分支信息 git fetch origin # fetch与pull的区别 git fetch # 只下载，不合并 git pull # 下载并合并 分支管理 主要分支结构\n1 2 3 4 5 main/master # 主分支，稳定版本 develop # 开发分支 feature/* # 功能分支 hotfix/* # 修复分支 release/* # 发布分支 分支命名示例\n1 2 3 4 feature/login # 新功能 hotfix/bug-fix # 紧急修复 release/v1.0.0 # 发布版本 docs/api # 文档更新 工作流程 功能开发流程\n1 2 3 4 5 6 7 8 9 10 11 12 # 创建功能分支 git checkout develop git checkout -b feature/new-feature # 开发并提交 git add . git commit -m \u0026#34;feat: new feature\u0026#34; git push -u origin feature/new-feature # 完成合并 git checkout develop git merge feature/new-feature 发布流程\n1 2 3 4 5 6 7 # 创建发布分支 git checkout -b release/v1.0.0 develop # 完成发布 git checkout main git merge release/v1.0.0 git tag v1.0.0 规范标准 提交信息规范\n1 2 3 4 5 6 7 feat: 新功能 fix: 修复bug docs: 文档更新 style: 格式调整 refactor: 重构 test: 测试相关 chore: 构建/工具 最佳实践\n1 2 3 4 5 1. 定期同步上游更新 2. 功能完成提交PR 3. 保持提交信息清晰 4. 及时清理已合并分支 5. 重要节点打Tag标记 查看本地分支和远程分支对应关系 1 2 3 4 5 # 这会显示： # 所有远程分支 # 每个本地分支跟踪的远程分支 # 哪些分支需要同步 git remote show origin ","date":"2025-02-19T00:00:00Z","image":"https://raw.githubusercontent.com/chirouo/my_blog_img/main/xdc1.jpg","permalink":"https://example.com/p/git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","title":"Git学习总结"},{"content":"多媒体相关技术总结 1. MIPI（Mobile Industry Processor Interface） 定义：一组用于移动设备的硬件接口标准。 作用：主要用于摄像头（CSI）、显示屏（DSI）等设备的连接。 应用：智能手机、平板电脑等移动设备。 2. RTSP（Real-Time Streaming Protocol） 定义：一种网络流媒体传输协议。 作用：用于控制实时音视频流的传输（如播放、暂停、快进）。 应用：视频监控、直播等场景。 3. FFmpeg 定义：开源的多媒体处理框架。 作用：支持音视频的编解码、转码、流媒体处理等。 工具：ffmpeg（命令行工具）、ffplay（播放器）、ffprobe（分析工具）。 4. MP4（MPEG-4 Part 14） 定义：一种常见的音视频容器格式。 特点：支持多种编码格式（如 H.264、AAC），文件体积较小。 应用：视频文件、流媒体等。 5. AVI（Audio Video Interleave） 定义：一种较老的音视频容器格式。 特点：兼容性较好，但文件体积通常较大。 应用：早期视频存储。 6. H.264/H.265 定义：视频编码标准。 作用：压缩视频数据，减少文件体积，保持高画质。 应用：广泛应用于视频编码。 7. ONVIF（Open Network Video Interface Forum） 定义：一种网络视频设备的标准协议。 作用：实现不同厂商的网络摄像头和视频管理系统的互操作性。 应用：视频监控。 8. RTP（Real-time Transport Protocol） 定义：一种用于实时音视频数据传输的协议。 作用：通常与 RTSP 配合使用，RTSP 负责控制，RTP 负责传输。 应用：实时音视频流传输。 9. HDMI（High-Definition Multimedia Interface） 定义：一种高清音视频接口标准。 作用：用于连接显示器、电视等设备，传输高清音视频信号。 应用：消费电子设备。 10. GStreamer 定义：开源的多媒体处理框架。 作用：支持音视频的采集、处理、播放等。 应用：多媒体处理，可替代 FFmpeg。 11. WebRTC（Web Real-Time Communication） 定义：一种支持浏览器实时音视频通信的技术。 作用：用于视频会议、直播等场景。 应用：Web 环境下的实时通信。 12. FLV（Flash Video） 定义：一种用于网络流媒体的视频容器格式。 特点：适用于早期的网络视频播放。 应用：网络流媒体。 技术关系图 1 2 3 4 5 6 7 MIPI（硬件接口） → 采集图像数据 ↓ FFmpeg（处理工具） → 编码、转码、流处理 ↓ RTSP/RTP（传输协议） → 实时音视频流传输 ↓ MP4/AVI（存储格式） → 存储音视频数据 ","date":"0001-01-01T00:00:00Z","permalink":"https://example.com/p/","title":""}]